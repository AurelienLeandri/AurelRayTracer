#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <memory>

class CameraSample;

class Sampler
{
public:
	Sampler(size_t samplesPerPixel);

public:
	// Clones the sampler
	virtual Sampler* clone(int seed) const = 0;

	// Indicate which pixel isbeing sampled, potentially for adaptive sampling techniques.
	virtual void startPixel(const glm::ivec2& pixel);

	// Returns next 1 or 2 samples. Using get2D allows the sampler to do some optimization.
	virtual float get1D() = 0;
	virtual glm::vec2 get2D() = 0;

	// Pre-generates arrays of samples on demand. Must be called before rendering, usually in the SamplerIntegrator::preprocess() method.
	void request1DArray(int n);
	void request2DArray(int n);

	// Returns the arrays of samples generated by theabove Request* functions. n is given by the caller to check that the array has the expected size.
	const float* get1DArray(int n);
	const glm::vec2* get2DArray(int n);

	// Positions the sample pointer at the first component of the next sample. Returns true until samplesPerPixel samples have been generated.
	virtual bool startNextSample();

	// Generate sample values for camera samples.
	CameraSample generateCameraSample(const glm::ivec2& pixel);

	// Returns the number of samples per pixel.
	int getSamplesPerPixel() const;

protected:
	glm::ivec2 _currentPixel = glm::ivec2(0, 0);
	size_t _currentPixelSampleIndex = 0;
	size_t _samplesPerPixel;
	std::vector<int> _samples1DArraySizes, _samples2DArraySizes;
	std::vector<std::vector<float>> _sampleArray1D;
	std::vector<std::vector<glm::vec2>> _sampleArray2D;
	size_t array1DOffset = 0, array2DOffset = 0;
};
